#ifndef PROJECT_TOKEN_H
#define PROJECT_TOKEN_H

#include <string>
#include <stdexcept>

enum Type {IDENT, OP, RELOP, LBRACE, RBRACE,
            LPAREN, RPAREN, IF, WHILE,
            SEMIC, FUNCTION, DTYPE, CALL,
            RETURN, ASSIGN, END, NUMBER,
            INPUT, PRINT, NOT, ENDIF, DONE, COMMA,
            COMPAND, COMPOR, STRINGLIT,
            THEN, ELSE};

extern std::string TypeEnumNames[];

enum VariableType {DOUBLE, STRING, VOID, ANY}; //any never generated by lexer

extern std::string VariableTypeEnumNames[];

enum Relop {EQ, NE, LT, LE, GT, GE};

template <typename T>
bool evaluateRelop(T LHS, Relop rel, T RHS)
{
    switch (rel)
    {
        case EQ:
            return LHS == RHS;
        case NE:
            return LHS != RHS;
        case LT:
            return LHS < RHS;
        case LE:
            return LHS <= RHS;
        case GT:
            return LHS > RHS;
        case GE:
            return LHS >= RHS;
        default:
            throw std::runtime_error("Bad relop encountered");
    }
}

extern std::string relEnumStrs[];

enum Op {PLUS, MULT, MINUS, DIV, MOD, AND, OR};

extern char opEnumChars[];

class Token
{
public:
    typedef union at
    {
        Relop relType;
        Op opType;
        VariableType vType;

        at(Relop rel): relType(rel) {};
        at(Op op): opType(op) {};
        at(VariableType vt): vType (vt) {};
        at(): opType{} {};

        operator Relop () const {return relType;}
        operator Op () const {return opType;}
        operator VariableType () const {return vType;}
    } AuxTypeUnion;

    Type type;
    AuxTypeUnion auxType;
    unsigned int line;
    std::string lexemeString;

    Token(Type t, std::string s = ""):
            type(t),
            auxType{},
            lexemeString(s){}

    Token(VariableType t, std::string s = ""):
            type(DTYPE),
            auxType(t),
            lexemeString(s){}

    Token(Relop rel):
            type(RELOP),
            auxType(rel)
    {
        switch((Relop)auxType)
        {
            case EQ:
                lexemeString = "==";
                break;
            case NE:
                lexemeString = "!=";
                break;
            case LT:
                lexemeString = "<";
                break;
            case LE:
                lexemeString = "<=";
                break;
            case GT:
                lexemeString = ">";
                break;
            case GE:
                lexemeString = ">=";
                break;
        }
    }

    Token(Op op):
            type(OP),
            auxType(op) {}

    Token():
            type{},
            auxType{} {}

    void setLine(unsigned int);

    friend std::ostream& operator<< (std::ostream& stream, const Token& token);
};

#endif